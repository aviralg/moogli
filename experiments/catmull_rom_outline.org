There are 2 parts of this algorithm -

1) The core interpolator - Takes the four rings between which the interpolation has to happen. 
                           Interpolation is done between the middle two using the remaining two as guide rings.
                           Its completely oblivious of the application domain. 
                           All it knows is the catmull rom algorithm and it applies it for all the points in the ring with the provided resolution

2 The driver - Calls the interpolator for giving a continuous neuronal representation.
               Needs to know of the application domain.
               It covers all possible cases of multiple childrent, no children, no parent

The interpolation for any compartment is done in two halves -

The proximal half and distal half

Proximal Half cases -

At each step of the algorithm, we just generate the distal half of the compartment in question and proximal half of all the children.
* Driver Algorithm

Assume the following parameters

- r_c - Current Compartment's radius
- l_c - Current Compartment's length
- d_c - Current Compartment's direction
- c_c - Current Compartment's center
- r_p - Parent Compartment's radius
- l_p - Parent Compartment's length
- d_p - Parent Compartment's direction
- c_p - Parent Compartment's center
- r_t - Tangent circle radius
- l_t - Tangent circle distance from center of parent

** Compartment Type
*** Root
Draw a central sphere with radius equal to the radius of the largest compartment
For each child in current compartment's children:
    R1 - Central circle of sphere
    R2 - Tangent circle with respect to the current child
    R3 - Child's central circle 
    R4 - Child's distal circle if child has multiple children or child is leaf
         else child's child's central ring
*** Leaf
Connect current compartment's central circle to distal circle.

*** Internal
This means the current compartment has a valid parent and at least one child compartment.
**** Parent Type
***** Root
for child in current compartment's children
  R1 - parent's tangent circle 
  R2 - Current compartment's central circle 
  R3 - Child's central circle
  R4 - Child's distal circle if child has multiple children or child is leaf
       else child's child's central circle
***** Internal
for child in current compartment's children
  R1 - Parent's central circle
  R2 - Current compartment's central circle
  R3 - Child's central circle
  R4 - Child's distal circle if child has multiple children or child is leaf
       else child's child's central circle

l = (r_p + l_c) / 2
a = r_c / l
b =  sqrt(r_p^2)/ r_s

* Cases for interpolate function

Takes 4 parameters -
 - grandparent
 - parent
 - child
 - grandchild

 if all parameters are null, then draw a sphere 
 if grandparent is null, and parent is null then current compartment is root.
 if only grandparent is null, then parent is root
 if grandchild is null then 

       | Grandparent | Parent  | Child   | grandchild | Explanation                   |
       |-------------+---------+---------+------------+-------------------------------|
       |  nullptr    | nullptr | nullptr |   nullptr  | Draw a sphere for the soma    |
       |  nullptr    | nullptr | nullptr |   valid    | Nonsense                      |
       |  nullptr    | nullptr | valid   |   nullptr  | 



 

#+BEGIN_SRC c++
class CatmullRomShape(Shape)
{
private:
public:
interpolate();
};

void
CatmullRomShape::

void
CatmullRomShape::interpolate( CatmullRomShape * grandparent
                            , CatmullRomShape * parent
                            , CatmullRomShape * child
                            , CatmullRomShape * grandchild)
{
    bool grandparentless = grandparent == nullptr;
    bool parentless = parent == nullptr;
    bool childless = child == nullptr;
    bool grandchildless = grandchild == nullptr;
    bool root;
   // bool root_child = grandparentless && 
  
    typedef void (*function)(CatmullRom *, CatmullRom *, CatmullRom *, CatmullRom *);
    
    function interpolators[] = {   make_soma
                               };

    switch(value)
    {
        case 0  : _interpolate_soma();
        default: break;
    }
    if(grandparent == nullptr && parent == nullptr)
    {
    // we have just begun interpolating.
         if(child == nullptr && grandchild == nullptr)
         {
             // draw soma as sphere
         }
         assert(child != nullptr);
         // R1 => Tange precircle wrt child
         // R2 => Tangent circle wrt child
         // R3 => Central circle of the protruding part of child
         if(grandchild == nullptr)
         {
             // R4 => Distal circle of child
         }
         else
         {
             // R4 => Central circle of child
         }
    } 
    if(grandparent == nullptr)
    {
        if(parent == nullptr)
        {
            if(child == nullptr)
            {
                // draw a sphere for root
            }
            else
            {
                if(
            }
        }
        else
        {
            // parent is root
            if(grandchild == nullptr)
            {
               // use child's distal circle
            }
            else
            {
                // use grandchild's central circle
            }
        }
    }
    if(  grandparent == nullptr && parent == nullptr 
      && child = nullptr && grandchild == nullptr)
    {
        // draw sphere
        return;
    }
    if( grandparent
}
#+END_SRC
