<html>
<head>
<title>points</title>
<meta name='robots' content='noindex,nofollow'>
<meta name='generator' content='GLOBAL-5.7.1'>
</head>
<body text='#191970' bgcolor='#f5f5dc' vlink='gray'>
<pre>
<a href='../S/16.html#L48'>points</a>             48 include/mesh/CylinderMesh.hpp               , unsigned int points
<a href='../S/16.html#L59'>points</a>             59 include/mesh/CylinderMesh.hpp               , unsigned int points
<a href='../S/16.html#L68'>points</a>             68 include/mesh/CylinderMesh.hpp               , unsigned int points
<a href='../S/16.html#L76'>points</a>             76 include/mesh/CylinderMesh.hpp               , unsigned int points
<a href='../S/16.html#L95'>points</a>             95 include/mesh/CylinderMesh.hpp     unit(unsigned int points = 10);
<a href='../S/15.html#L39'>points</a>             39 include/mesh/SphereMesh.hpp               , unsigned int points
<a href='../S/15.html#L47'>points</a>             47 include/mesh/SphereMesh.hpp               , unsigned int points
<a href='../S/15.html#L64'>points</a>             64 include/mesh/SphereMesh.hpp     unit(unsigned int points = 10);
<a href='../S/1.html#L11'>points</a>             11 src/mesh/CylinderMesh.cpp CylinderMesh::unit(unsigned int points)
<a href='../S/1.html#L16'>points</a>             16 src/mesh/CylinderMesh.cpp     auto result = cylinders.find(points);
<a href='../S/1.html#L21'>points</a>             21 src/mesh/CylinderMesh.cpp     unsigned int vertex_count   = 2 * points;
<a href='../S/1.html#L22'>points</a>             22 src/mesh/CylinderMesh.cpp     unsigned int triangle_count = 12 * points - 12;
<a href='../S/1.html#L29'>points</a>             29 src/mesh/CylinderMesh.cpp     float theta_delta = 2.0 * M_PI / points;
<a href='../S/1.html#L45'>points</a>             45 src/mesh/CylinderMesh.cpp     for(i = 0; i &lt; points; ++i)
<a href='../S/1.html#L55'>points</a>             55 src/mesh/CylinderMesh.cpp         (*vertices)[i + points] = Vec3f(x, y, -0.5f);
<a href='../S/1.html#L56'>points</a>             56 src/mesh/CylinderMesh.cpp         (*vertices)[i + 2 * points] = Vec3f(x, y,  0.5f);
<a href='../S/1.html#L57'>points</a>             57 src/mesh/CylinderMesh.cpp         (*vertices)[i + 3 * points] = Vec3f(x, y, -0.5f);
<a href='../S/1.html#L62'>points</a>             62 src/mesh/CylinderMesh.cpp         (*normals)[i + points]  = Vec3f(x,y,0.0f);
<a href='../S/1.html#L63'>points</a>             63 src/mesh/CylinderMesh.cpp         (*normals)[i + 2 * points] = Vec3f(0.0f, 0.0f, 1.0f);
<a href='../S/1.html#L64'>points</a>             64 src/mesh/CylinderMesh.cpp         (*normals)[i + 3 * points]  = Vec3f( 0.0f, 0.0f, -1.0f);
<a href='../S/1.html#L71'>points</a>             71 src/mesh/CylinderMesh.cpp     for(i = 0; i &lt; points; ++i)
<a href='../S/1.html#L74'>points</a>             74 src/mesh/CylinderMesh.cpp         (*indices)[triangle_index + 1] = i + points;
<a href='../S/1.html#L77'>points</a>             77 src/mesh/CylinderMesh.cpp         (*indices)[triangle_index + 3] = i + points;
<a href='../S/1.html#L78'>points</a>             78 src/mesh/CylinderMesh.cpp         (*indices)[triangle_index + 4] = i + 1 + points;
<a href='../S/1.html#L85'>points</a>             85 src/mesh/CylinderMesh.cpp     (*indices)[triangle_index - 2]     = points;
<a href='../S/1.html#L88'>points</a>             88 src/mesh/CylinderMesh.cpp     for(i = 2 * points + 1; i &lt; 3 * points - 1; ++i)
<a href='../S/1.html#L90'>points</a>             90 src/mesh/CylinderMesh.cpp         (*indices)[triangle_index    ] = 2 * points;
<a href='../S/1.html#L96'>points</a>             96 src/mesh/CylinderMesh.cpp     for(i = 3 * points + 1; i &lt; 4 * points - 1; ++i)
<a href='../S/1.html#L100'>points</a>            100 src/mesh/CylinderMesh.cpp         (*indices)[triangle_index + 2] = 3 * points;
<a href='../S/1.html#L105'>points</a>            105 src/mesh/CylinderMesh.cpp         cylinders.insert( make_pair( points
<a href='../S/1.html#L131'>points</a>            131 src/mesh/CylinderMesh.cpp                         , unsigned int points
<a href='../S/1.html#L136'>points</a>            136 src/mesh/CylinderMesh.cpp     const auto arrays = unit(points);
<a href='../S/1.html#L172'>points</a>            172 src/mesh/CylinderMesh.cpp         for(i = 0; i &lt; points; ++i)
<a href='../S/1.html#L174'>points</a>            174 src/mesh/CylinderMesh.cpp             temp_vertex.set( (*vertices)[i + points][0]
<a href='../S/1.html#L175'>points</a>            175 src/mesh/CylinderMesh.cpp                            , (*vertices)[i + points][1]
<a href='../S/1.html#L182'>points</a>            182 src/mesh/CylinderMesh.cpp                 (*vertices)[i + 3 * points][2] = (*vertices)[i + points][2] =
<a href='../S/1.html#L187'>points</a>            187 src/mesh/CylinderMesh.cpp                 (*vertices)[i + 3 * points][2] = (*vertices)[i + points][2] =
<a href='../S/1.html#L192'>points</a>            192 src/mesh/CylinderMesh.cpp                 (*vertices)[i + 3 * points][2] = (*vertices)[i + points][2] =
<a href='../S/1.html#L197'>points</a>            197 src/mesh/CylinderMesh.cpp                 (*vertices)[i + 3 * points][2] = (*vertices)[i + points][2] =
<a href='../S/1.html#L205'>points</a>            205 src/mesh/CylinderMesh.cpp     for(i = 0; i &lt; points; ++i)
<a href='../S/1.html#L211'>points</a>            211 src/mesh/CylinderMesh.cpp         (*vertices)[i + 2 * points] = (*vertices)[i] = rotate * temp_vertex + center;
<a href='../S/1.html#L212'>points</a>            212 src/mesh/CylinderMesh.cpp         (*normals)[i + points]  = (*normals)[i]  = rotate * (*unit_normals)[i];
<a href='../S/1.html#L213'>points</a>            213 src/mesh/CylinderMesh.cpp         (*normals)[i + 2 * points] = direction;
<a href='../S/1.html#L214'>points</a>            214 src/mesh/CylinderMesh.cpp         (*normals)[i + 3 * points] = -direction;
<a href='../S/1.html#L215'>points</a>            215 src/mesh/CylinderMesh.cpp         j = i + points;
<a href='../S/1.html#L221'>points</a>            221 src/mesh/CylinderMesh.cpp         (*vertices)[j + 2 * points] = (*vertices)[j] = rotate * temp_vertex + center;
<a href='../S/1.html#L254'>points</a>            254 src/mesh/CylinderMesh.cpp                         , unsigned int points
<a href='../S/1.html#L267'>points</a>            267 src/mesh/CylinderMesh.cpp               , points
<a href='../S/1.html#L279'>points</a>            279 src/mesh/CylinderMesh.cpp                         , unsigned int points
<a href='../S/1.html#L304'>points</a>            304 src/mesh/CylinderMesh.cpp               , points
<a href='../S/1.html#L313'>points</a>            313 src/mesh/CylinderMesh.cpp                         , unsigned int points
<a href='../S/1.html#L322'>points</a>            322 src/mesh/CylinderMesh.cpp               , points
<a href='../S/2.html#L13'>points</a>             13 src/mesh/SphereMesh.cpp SphereMesh::unit(unsigned int points)
<a href='../S/2.html#L18'>points</a>             18 src/mesh/SphereMesh.cpp     auto result = spheres.find(points);
<a href='../S/2.html#L23'>points</a>             23 src/mesh/SphereMesh.cpp     unsigned int vertex_count   = (points * points) / 2 - points + 2;
<a href='../S/2.html#L24'>points</a>             24 src/mesh/SphereMesh.cpp     unsigned int triangle_count = 3 * points * points - 6 * points;
<a href='../S/2.html#L32'>points</a>             32 src/mesh/SphereMesh.cpp     float phi_delta   = 2.0 * M_PI / points;
<a href='../S/2.html#L33'>points</a>             33 src/mesh/SphereMesh.cpp     float theta_delta = 2.0 * M_PI / points;
<a href='../S/2.html#L47'>points</a>             47 src/mesh/SphereMesh.cpp     for(i = 1; i &lt; points / 2; ++i)
<a href='../S/2.html#L51'>points</a>             51 src/mesh/SphereMesh.cpp         for(j = 0; j &lt; points; ++j)
<a href='../S/2.html#L66'>points</a>             66 src/mesh/SphereMesh.cpp     for(i = 0; i &lt; points; ++i)
<a href='../S/2.html#L76'>points</a>             76 src/mesh/SphereMesh.cpp     for(i = 1; i &lt; points / 2 - 1; ++i)
<a href='../S/2.html#L78'>points</a>             78 src/mesh/SphereMesh.cpp         alpha = 1 + points * (i - 1);
<a href='../S/2.html#L79'>points</a>             79 src/mesh/SphereMesh.cpp         beta  = 1 + points * i;
<a href='../S/2.html#L81'>points</a>             81 src/mesh/SphereMesh.cpp         for(j = 0; j &lt; points; ++j)
<a href='../S/2.html#L97'>points</a>             97 src/mesh/SphereMesh.cpp     for(i = 0; i &lt; points; ++i)
<a href='../S/2.html#L107'>points</a>            107 src/mesh/SphereMesh.cpp     auto insert_position = spheres.insert(make_pair( points
<a href='../S/2.html#L120'>points</a>            120 src/mesh/SphereMesh.cpp                       , unsigned int points
<a href='../S/2.html#L128'>points</a>            128 src/mesh/SphereMesh.cpp               , points
<a href='../S/2.html#L138'>points</a>            138 src/mesh/SphereMesh.cpp                       , unsigned int points
<a href='../S/2.html#L142'>points</a>            142 src/mesh/SphereMesh.cpp     const auto arrays = unit(points);
</pre>
</body>
</html>
